<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>RGB Light Circles</title>
	<link rel="stylesheet" href="https://use.typekit.net/gti1nvp.css">
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: "noka", sans-serif;
			overflow-x: hidden;
			background: black;
			height: 100vh;
		}

		.canvas-container {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			z-index: 1;
		}

		.circles-layer {
			position: absolute;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
		}

		.circle {
			position: absolute;
			border-radius: 50%;
			mix-blend-mode: screen;
			transition: transform 0.1s ease-out;
		}

		.circle-red {
			background: radial-gradient(
				closest-side,
				rgba(255,0,0,1.0) 0%,
				rgba(255,0,0,0.8) 50%,
				rgba(255,0,0,0.6) 80%,
				rgba(255,0,0,0.4) 90%,
				rgba(255,0,0,0.0) 100%
			);
		}

		.circle-green {
			background: radial-gradient(
				closest-side,
				rgba(0,255,0,1.0) 0%,
				rgba(0,255,0,0.8) 50%,
				rgba(0,255,0,0.6) 80%,
				rgba(0,255,0,0.4) 90%,
				rgba(0,255,0,0.0) 100%
			);
		}

		.circle-blue {
			background: radial-gradient(
				closest-side,
				rgba(0,0,255,1.0) 0%,
				rgba(0,0,255,0.8) 50%,
				rgba(0,0,255,0.6) 80%,
				rgba(0,0,255,0.4) 90%,
				rgba(0,0,255,0.0) 100%
			);
		}

		.content {
			position: relative;
			z-index: 2;
			min-height: 100vh;
			padding: 6rem;
			max-width: 800px;
			margin: 0 auto;
			color: white;
			mix-blend-mode: difference;
			overflow-y: auto;
		}

		.heading {
			font-family: "noka", sans-serif;
			font-weight: 900;
			font-style: normal;
			font-size: clamp(2.5rem, 8vw, 6rem);
			margin-bottom: 2rem;
			line-height: 1.1;
			text-align: left;
		}

		.text-content {
			font-family: "noka", sans-serif;
			font-weight: 600;
			font-style: normal;
			font-size: clamp(1rem, 3vw, 1.5rem);
			line-height: 1.6;
			text-align: left;
		}

		.paragraph {
			margin-bottom: 2rem;
		}

		@media (max-width: 768px) {
			.content {
				padding: 1rem;
			}

			.text-content {
				text-align: left;
			}
		}

		.gyro-modal {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: rgba(0,0,0,0.9);
			padding: 2rem;
			border-radius: 5px;
			z-index: 10;
			text-align: center;
			border: 1px solid rgba(255,255,255,0.2);
		}

		.gyro-button {
			background: rgba(255,255,255,0.2);
			color: white;
			border: none;
			padding: 1rem 2rem;
			border-radius: 5px;
			font-size: 1.2rem;
			cursor: pointer;
			font-family: "noka", sans-serif;
			font-weight: 600;
			margin-bottom: 1rem;
			display: block;
			width: 100%;
		}

		.gyro-cancel {
			background: rgba(100,100,100,0.5);
			color: white;
			border: none;
			padding: 0.5rem 1rem;
			border-radius: 5px;
			font-size: 0.9rem;
			cursor: pointer;
			font-family: "noka", sans-serif;
			font-weight: 400;
			display: block;
			width: 100%;
		}

		.controls-bar {
			position: fixed;
			bottom: 0;
			left: 0;
			right: 0;
			background: black;
			padding: 1rem;
			display: flex;
			justify-content: center;
			gap: 2rem;
			z-index: 5;
			mix-blend-mode: normal;
		}

		.toggle-button {
			background: grey;
			color: black;
			border: none;
			padding: 0.5rem 1rem;
			border-radius: 5px;
			cursor: pointer;
			font-family: "noka", sans-serif;
			font-weight: 600;
			font-size: 0.9rem;
			transition: background 0.2s ease;
			min-width: 80px;
		}

		.toggle-button.active {
			background: white;
		}

		.toggle-button:hover {
			background: rgba(255,255,255,0.5);
		}

		.reduced-motion .circle {
			transition: none !important;
			transform: none !important;
		}

		.reduced-motion .circles-layer {
			opacity: 0.5;
		}

		.reduced-motion .content {
			color: white;
			mix-blend-mode: normal;
		}

		.debug-console {
			position: fixed;
			top: 10px;
			left: 10px;
			background: rgba(0,0,0,0.8);
			color: white;
			padding: 10px;
			border-radius: 5px;
			font-family: monospace;
			font-size: 12px;
			max-width: 300px;
			z-index: 20;
			display: none;
		}
	</style>
</head>
<body>
	<div class="canvas-container">
		<div class="circles-layer">
			<div class="circle circle-red" id="redCircle"></div>
			<div class="circle circle-green" id="greenCircle"></div>
			<div class="circle circle-blue" id="blueCircle"></div>
		</div>
	</div>

	<div class="content">
		<h1 class="heading" id="mainHeading">RGB Light Mixing</h1>

		<div class="text-content" id="textContent">
		</div>
	</div>

	<div class="gyro-modal" id="gyroModal">
		<button class="gyro-button" id="gyroButton">Enable Gyroscope</button>
		<button class="gyro-cancel" id="gyroCancel">Cancel</button>
	</div>

	<div class="controls-bar">
		<button class="toggle-button active" id="langToggle">EN</button>
		<button class="toggle-button active" id="motionToggle">MOTION</button>
	</div>

	<div class="debug-console" id="debugConsole">
		<div>Debug Console:</div>
		<div id="debugOutput"></div>
	</div>

	<script>
		// Debug system for visual feedback
		class DebugSystem {
			constructor() {
				this.console = document.getElementById('debugConsole');
				this.output = document.getElementById('debugOutput');
				this.logs = [];
				this.maxLogs = 8;

				// Show debug on mobile or when needed
				if (this.isMobile()) {
					this.console.style.display = 'block';
				}
			}

			isMobile() {
				return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
			}

			log(message) {
				console.log(message);
				this.logs.push(`${new Date().toLocaleTimeString()}: ${message}`);
				if (this.logs.length > this.maxLogs) {
					this.logs.shift();
				}
				this.output.innerHTML = this.logs.join('<br>');
			}

			show() {
				this.console.style.display = 'block';
			}

			hide() {
				this.console.style.display = 'none';
			}
		}

		// Initialize debug system
		const debug = new DebugSystem();

		// Language content
		const content = {
			en: {
				heading: "COLOUR SPACE",
				button: "Enable Gyroscope",
				cancel: "Cancel",
				motion: "MOTION",
				paragraphs: [
					"Light mixing is a fundamental principle in physics and visual arts, where different colored lights combine to create new hues through additive color synthesis. Unlike pigment mixing, which is subtractive, light mixing follows the RGB (Red, Green, Blue) color model where colors become brighter as they overlap.",
					"When pure red, green, and blue lights intersect, they create secondary colors: red and green produce yellow, blue and green create cyan, and red and blue form magenta. Where all three primary lights converge, white light emerges—the complete visible spectrum unified.",
					"This phenomenon occurs naturally in various contexts: stage lighting design, computer displays, LED arrays, and even in the aurora borealis where charged particles excite atmospheric gases to emit different colored lights that dance and blend across the night sky.",
					"The gyroscopic movement you're experiencing mirrors how light itself moves and shifts in space. Motion sensors in your device detect orientation changes and translate them into subtle positional shifts of the light circles, creating an immersive, responsive environment that reacts to your physical interaction with the device.",
					"Thomas Young's double-slit experiment first demonstrated light's wave nature, while James Clerk Maxwell later proved that light consists of electromagnetic waves. These discoveries laid the groundwork for understanding how different wavelengths combine to create the rich spectrum of colors we perceive.",
					"In digital displays, millions of tiny RGB sub-pixels work together to create every image you see. Each pixel contains red, green, and blue elements that can be individually controlled to produce any color within the display's gamut—a testament to the power of additive light mixing.",
					"The soft edges and falloff you observe in these circles simulate how light naturally behaves in the physical world. Light intensity decreases with distance from the source, creating gradual transitions rather than sharp boundaries. This natural falloff is what makes light mixing so visually appealing and realistic.",
					"Continue scrolling to explore how these fundamental principles of light and color create an endless dance of hues, where science meets art in a symphony of electromagnetic radiation that our eyes interpret as the beautiful phenomenon we call color."
				]
			},
			pl: {
				heading: "PRZESTRZEŃ BARW",
				button: "Włącz żyroskop",
				cancel: "Anuluj",
				motion: "RUCH",
				paragraphs: [
					"Mieszanie światła jest fundamentalną zasadą fizyki i sztuk wizualnych, gdzie różnokolorowe światła łączą się, tworząc nowe odcienie poprzez addytywną syntezę kolorów. W przeciwieństwie do mieszania pigmentów, które jest subtraktywne, mieszanie światła opiera się na modelu RGB (czerwony, zielony, niebieski), gdzie kolory stają się jaśniejsze podczas nakładania.",
					"Gdy czyste czerwone, zielone i niebieskie światła przecinają się, tworzą kolory wtórne: czerwony i zielony dają żółty, niebieski i zielony tworzą cyjan, a czerwony i niebieski formują magentę. Tam, gdzie wszystkie trzy podstawowe światła zbiegają się, powstaje białe światło—kompletne widmo widzialne zjednoczone.",
					"To zjawisko występuje naturalnie w różnych kontekstach: projektowanie oświetlenia scenicznego, wyświetlacze komputerowe, macierze LED, a nawet w zorzy polarnej, gdzie naładowane cząsteczki pobudzają gazy atmosferyczne do emitowania różnokolorowych świateł, które tańczą i mieszają się na nocnym niebie.",
					"Żyroskopowy ruch, którego doświadczasz, odzwierciedla sposób, w jaki samo światło porusza się i zmienia w przestrzeni. Czujniki ruchu w Twoim urządzeniu wykrywają zmiany orientacji i przekładają je na subtelne przesunięcia pozycyjne kręgów światła, tworząc immersyjne, responsywne środowisko reagujące na Twoją fizyczną interakcję z urządzeniem.",
					"Eksperyment podwójnej szczeliny Thomasa Younga po raz pierwszy wykazał falową naturę światła, podczas gdy James Clerk Maxwell później udowodnił, że światło składa się z fal elektromagnetycznych. Te odkrycia położyły podwaliny pod zrozumienie tego, jak różne długości fal łączą się, tworząc bogate spektrum kolorów, które postrzegamy.",
					"W wyświetlaczach cyfrowych miliony maleńkich subpikseli RGB współpracują, aby stworzyć każdy obraz, który widzisz. Każdy piksel zawiera czerwone, zielone i niebieskie elementy, które mogą być indywidualnie kontrolowane, aby wytworzyć każdy kolor w gamie wyświetlacza—świadectwo mocy addytywnego mieszania światła.",
					"Miękkie krawędzie i opadanie, które obserwujesz w tych kręgach, symuluje sposób, w jaki światło naturalnie zachowuje się w świecie fizycznym. Intensywność światła maleje wraz z odległością od źródła, tworząc stopniowe przejścia zamiast ostrych granic. To naturalne opadanie sprawia, że mieszanie światła jest tak wizualnie atrakcyjne i realistyczne.",
					"Kontynuuj przewijanie, aby zbadać, jak te fundamentalne zasady światła i koloru tworzą niekończący się taniec odcieni, gdzie nauka spotyka się ze sztuką w symfonii promieniowania elektromagnetycznego, które nasze oczy interpretują jako piękne zjawisko, które nazywamy kolorem."
				]
			}
		};

		class RGBLightMixer {
			constructor() {
				debug.log('RGBLightMixer: Starting initialization');

				this.circles = {
					red: document.getElementById('redCircle'),
					green: document.getElementById('greenCircle'),
					blue: document.getElementById('blueCircle')
				};

				this.gyroModal = document.getElementById('gyroModal');
				this.gyroButton = document.getElementById('gyroButton');
				this.gyroCancel = document.getElementById('gyroCancel');

				this.gyroEnabled = false;
				this.currentLanguage = this.detectLanguage();
				this.motionReduced = false;
				this.lastGyroTime = 0;

				debug.log(`Device: ${navigator.userAgent}`);
				debug.log(`Language detected: ${this.currentLanguage}`);

				// Load saved preferences
				this.loadPreferences();

				// Random movement directions for each circle
				this.circleDirections = {
					red: { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 },
					green: { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 },
					blue: { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 }
				};

				debug.log('Circle directions generated');
				this.init();
			}

			detectLanguage() {
				const userLang = navigator.language || navigator.userLanguage;
				return userLang.startsWith('pl') ? 'pl' : 'en';
			}

			loadPreferences() {
				try {
					// Don't show gyro prompt on desktop at all
					if (!this.isMobile()) {
						debug.log('Desktop detected - skipping gyro setup entirely');
						this.hideGyroPrompt();
					} else {
						// Only handle gyro on mobile devices
						const gyroPermission = localStorage.getItem('gyroPermission');
						debug.log(`Gyro permission in storage: ${gyroPermission}`);

						if (gyroPermission === 'granted') {
							this.tryAutoEnableGyro();
						} else if (gyroPermission === 'denied') {
							this.hideGyroPrompt();
						}
						// If no permission stored, leave modal visible for user choice
					}

					// Load language preference
					const savedLang = localStorage.getItem('preferredLanguage');
					if (savedLang) {
						this.currentLanguage = savedLang;
					}

					// Load motion preference
					this.motionReduced = localStorage.getItem('motionReduced') === 'true';
				} catch (e) {
					debug.log('LocalStorage not available: ' + e.message);
				}
			}

			savePreferences() {
				try {
					localStorage.setItem('preferredLanguage', this.currentLanguage);
					localStorage.setItem('motionReduced', this.motionReduced);
				} catch (e) {
					debug.log('Could not save preferences: ' + e.message);
				}
			}

			calculateCirclePositions() {
				const vw = window.innerWidth;
				const vh = window.innerHeight;

				const minDimension = Math.min(vw, vh);
				const circleSize = Math.max(minDimension * 1.2, 600);

				// Center point for triangle formation
				const centerX = vw / 2;
				const centerY = vh / 2;

				// Triangle formation
				const angle1 = Math.random() * Math.PI * 2;
				const angle2 = angle1 + (Math.PI * 2 / 3) + (Math.random() - 0.5) * 0.3;
				const angle3 = angle2 + (Math.PI * 2 / 3) + (Math.random() - 0.5) * 0.3;

				// Distance between circle centers
				const distance = Math.min(vw, vh) * 0.3;

				const positions = {
					red: {
						x: centerX + Math.cos(angle1) * distance - circleSize / 2,
						y: centerY + Math.sin(angle1) * distance - circleSize / 2,
						size: circleSize
					},
					green: {
						x: centerX + Math.cos(angle2) * distance - circleSize / 2,
						y: centerY + Math.sin(angle2) * distance - circleSize / 2,
						size: circleSize
					},
					blue: {
						x: centerX + Math.cos(angle3) * distance - circleSize / 2,
						y: centerY + Math.sin(angle3) * distance - circleSize / 2,
						size: circleSize
					}
				};

				return positions;
			}

			positionCircles() {
				const positions = this.calculateCirclePositions();

				Object.keys(positions).forEach(color => {
					const circle = this.circles[color];
					const pos = positions[color];

					circle.style.width = pos.size + 'px';
					circle.style.height = pos.size + 'px';
					circle.style.left = pos.x + 'px';
					circle.style.top = pos.y + 'px';
					circle.style.transform = 'none';
				});

				this.basePositions = positions;
				debug.log('Circles positioned');
			}

			async tryAutoEnableGyro() {
				debug.log('Trying to auto-enable gyroscope...');

				// Don't show gyro prompt on desktop
				if (!this.isMobile()) {
					debug.log('Desktop detected - hiding gyro prompt');
					this.hideGyroPrompt();
					return;
				}

				if (!('DeviceOrientationEvent' in window)) {
					debug.log('DeviceOrientationEvent not supported');
					this.hideGyroPrompt();
					return;
				}

				debug.log('Mobile device detected - gyro setup continuing');

				try {
					if (typeof DeviceOrientationEvent.requestPermission === 'function') {
						debug.log('iOS device detected - requestPermission function exists');
						// For iOS, we can't auto-enable, we need user interaction
						// Keep the prompt visible for user to click
					} else {
						debug.log('Non-iOS mobile device - attempting direct enable');
						this.enableGyroscope();
						this.hideGyroPrompt();
					}
				} catch (error) {
					debug.log('Auto-enable failed: ' + error.message);
				}
			}

			isMobile() {
				return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
			}

			hideGyroPrompt() {
				this.gyroModal.style.display = 'none';
				debug.log('Gyro prompt hidden');
			}

			setLanguage() {
				const lang = content[this.currentLanguage];

				document.getElementById('mainHeading').textContent = lang.heading;
				this.gyroButton.textContent = lang.button;
				this.gyroCancel.textContent = lang.cancel;

				const textContainer = document.getElementById('textContent');
				textContainer.innerHTML = lang.paragraphs.map(para => `<p class="paragraph">${para}</p>`).join('');

				document.getElementById('langToggle').textContent = this.currentLanguage.toUpperCase();
				document.getElementById('motionToggle').textContent = lang.motion;
				document.getElementById('motionToggle').classList.toggle('active', !this.motionReduced);
			}

			setupControls() {
				document.getElementById('langToggle').addEventListener('click', () => {
					this.currentLanguage = this.currentLanguage === 'en' ? 'pl' : 'en';
					this.setLanguage();
					this.savePreferences();
				});

				document.getElementById('motionToggle').addEventListener('click', () => {
					this.motionReduced = !this.motionReduced;
					document.body.classList.toggle('reduced-motion', this.motionReduced);
					document.getElementById('motionToggle').classList.toggle('active', !this.motionReduced);
					this.savePreferences();
				});

				if (this.motionReduced) {
					document.body.classList.add('reduced-motion');
				}
			}

			init() {
				debug.log('Initializing application...');
				this.setLanguage();
				this.setupControls();
				this.positionCircles();
				this.setupMouseControls();
				this.setupGyroButton();
				this.startAnimation();

				window.addEventListener('resize', () => {
					// Disabled to prevent repositioning on orientation change
				});

				debug.log('Application initialized');
			}

			setupMouseControls() {
				let mouseX = 0.5;
				let mouseY = 0.5;

				document.addEventListener('mousemove', (event) => {
					if (this.motionReduced) return;

					mouseX = event.clientX / window.innerWidth;
					mouseY = event.clientY / window.innerHeight;
					this.updateCirclePositions(mouseX, mouseY);
				});

				debug.log('Mouse controls setup');
			}

			setupGyroButton() {
				this.gyroButton.addEventListener('click', () => {
					debug.log('Gyro button clicked');
					this.requestGyroPermission();
				});

				this.gyroCancel.addEventListener('click', () => {
					debug.log('Gyro cancel clicked');
					try {
						localStorage.setItem('gyroPermission', 'denied');
					} catch (e) {
						debug.log('Could not save gyro preference');
					}
					this.hideGyroPrompt();
				});
			}

			async requestGyroPermission() {
				debug.log('Requesting gyroscope permission...');

				if (!('DeviceOrientationEvent' in window)) {
					debug.log('DeviceOrientationEvent not supported on this device');
					this.hideGyroPrompt();
					return;
				}

				try {
					if (typeof DeviceOrientationEvent.requestPermission === 'function') {
						debug.log('Calling DeviceOrientationEvent.requestPermission()');
						const permission = await DeviceOrientationEvent.requestPermission();
						debug.log('Permission result: ' + permission);

						if (permission === 'granted') {
							try {
								localStorage.setItem('gyroPermission', 'granted');
							} catch (e) {
								debug.log('Could not save gyro permission');
							}
							this.enableGyroscope();
							this.hideGyroPrompt();
						} else {
							debug.log('Permission denied by user');
							try {
								localStorage.setItem('gyroPermission', 'denied');
							} catch (e) {
								debug.log('Could not save gyro denial');
							}
							this.hideGyroPrompt();
						}
					} else {
						debug.log('No permission required - enabling directly');
						try {
							localStorage.setItem('gyroPermission', 'granted');
						} catch (e) {
							debug.log('Could not save gyro permission');
						}
						this.enableGyroscope();
						this.hideGyroPrompt();
					}
				} catch (error) {
					debug.log('Gyroscope error: ' + error.message);
					this.hideGyroPrompt();
				}
			}

			enableGyroscope() {
				this.gyroEnabled = true;
				debug.log('Gyroscope enabled - setting up event listener');

				const handleOrientation = (event) => {
					if (this.motionReduced) return;

					this.lastGyroTime = Date.now();

					// Get orientation values with fallbacks
					let beta = event.beta || 0;
					let gamma = event.gamma || 0;
					let alpha = event.alpha || 0;

					// Log raw values occasionally for debugging
					if (this.lastGyroTime % 1000 < 100) { // Log every ~1 second
						debug.log(`Raw gyro: α=${alpha.toFixed(1)}° β=${beta.toFixed(1)}° γ=${gamma.toFixed(1)}°`);
					}

					// Clamp values to expected ranges
					beta = Math.max(-180, Math.min(180, beta));
					gamma = Math.max(-90, Math.min(90, gamma));

					// Normalize to 0-1 range
					const normalizedX = (gamma + 90) / 180;
					const normalizedY = (beta + 180) / 360;

					this.updateCirclePositions(normalizedX, normalizedY);
				};

				// Add event listener
				window.addEventListener('deviceorientation', handleOrientation, { passive: true });
				debug.log('DeviceOrientation event listener added');

				// Test if gyro data is coming through
				setTimeout(() => {
					const timeSinceLastGyro = Date.now() - this.lastGyroTime;
					if (timeSinceLastGyro > 3000) {
						debug.log('Warning: No gyroscope data received in 3 seconds');
					} else {
						debug.log('Gyroscope data is flowing correctly');
					}
				}, 3000);
			}

			updateCirclePositions(inputX, inputY) {
				if (this.motionReduced || !this.basePositions) return;

				const offsetScale = 500;

				Object.keys(this.circles).forEach(color => {
					const circle = this.circles[color];
					const basePos = this.basePositions[color];
					const direction = this.circleDirections[color];

					const offsetX = (inputX - 0.5) * offsetScale * direction.x;
					const offsetY = (inputY - 0.5) * offsetScale * direction.y;

					circle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
				});
			}

			startAnimation() {
				let time = 0;

				const animate = () => {
					if (!this.gyroEnabled && !this.motionReduced) {
						time += 0.01;
						const autoX = 0.5 + Math.sin(time) * 0.1;
						const autoY = 0.5 + Math.cos(time * 0.7) * 0.1;
						this.updateCirclePositions(autoX, autoY);
					}

					requestAnimationFrame(animate);
				};

				animate();
				debug.log('Animation started');
			}
		}

		document.addEventListener('DOMContentLoaded', () => {
			debug.log('DOM loaded - starting RGBLightMixer');
			new RGBLightMixer();
		});
	</script>
</body>
</html>