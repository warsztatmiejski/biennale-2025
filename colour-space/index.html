<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>RGB Light Circles</title>
	<link rel="stylesheet" href="https://use.typekit.net/gti1nvp.css">
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: "noka", sans-serif;
			overflow-x: hidden;
			background: black;
			height: 100vh;
		}

		.canvas-container {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			z-index: 1;
		}

		.circles-layer {
			position: absolute;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
		}

		.circle {
			position: absolute;
			border-radius: 50%;
			mix-blend-mode: screen;
			transition: transform 0.1s ease-out;
		}

		.circle-red {
			background: radial-gradient(
				closest-side,
				rgba(255,0,0,1.0) 0%,
				rgba(255,0,0,0.8) 50%,
				rgba(255,0,0,0.6) 80%,
				rgba(255,0,0,0.4) 90%,
				rgba(255,0,0,0.0) 100%
			);
		}

		.circle-green {
			background: radial-gradient(
				closest-side,
				rgba(0,255,0,1.0) 0%,
				rgba(0,255,0,0.8) 50%,
				rgba(0,255,0,0.6) 80%,
				rgba(0,255,0,0.4) 90%,
				rgba(0,255,0,0.0) 100%
			);
		}

		.circle-blue {
			background: radial-gradient(
				closest-side,
				rgba(0,0,255,1.0) 0%,
				rgba(0,0,255,0.8) 50%,
				rgba(0,0,255,0.6) 80%,
				rgba(0,0,255,0.4) 90%,
				rgba(0,0,255,0.0) 100%
			);
		}

		.content {
			position: relative;
			z-index: 2;
			max-width: 800px;
			min-height: 100vh;
			padding: 6rem;
			color: white;
			mix-blend-mode: difference;
			overflow-y: auto;
		}

		.heading {
			font-family: "noka", sans-serif;
			font-weight: 900;
			font-style: normal;
			font-size: clamp(2.5rem, 8vw, 6rem);
			margin-bottom: 2rem;
			line-height: 1.1;
			text-align: left;
		}

		.text-content {
			font-family: "noka", sans-serif;
			font-weight: 600;
			font-style: normal;
			font-size: clamp(1rem, 3vw, 1.5rem);
			line-height: 1.6;
			margin: 0 auto;
			text-align: left;
		}

		.paragraph {
			margin-bottom: 2rem;
		}

		@media (max-width: 768px) {
			.content {
				padding: 1rem;
			}

			.text-content {
				text-align: left;
			}
		}

		.gyro-modal {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: rgba(0,0,0,0.9);
			padding: 2rem;
			border-radius: 5px;
			z-index: 10;
			text-align: center;
			border: 1px solid rgba(255,255,255,0.2);
		}

		.gyro-button {
			background: rgba(255,255,255,0.2);
			color: white;
			border: none;
			padding: 1rem 2rem;
			border-radius: 5px;
			font-size: 1.2rem;
			cursor: pointer;
			font-family: "noka", sans-serif;
			font-weight: 600;
			margin-bottom: 1rem;
			display: block;
			width: 100%;
		}

		.gyro-cancel {
			background: rgba(100,100,100,0.5);
			color: white;
			border: none;
			padding: 0.5rem 1rem;
			border-radius: 5px;
			font-size: 0.9rem;
			cursor: pointer;
			font-family: "noka", sans-serif;
			font-weight: 400;
			display: block;
			width: 100%;
		}

		.controls-bar {
			position: fixed;
			bottom: 0;
			left: 0;
			right: 0;
			background: black;
			padding: 1rem;
			display: flex;
			justify-content: center;
			gap: 2rem;
			z-index: 5;
			mix-blend-mode: normal;
		}

		.toggle-button {
			background: grey;
			color: black;
			border: none;
			padding: 0.5rem 1rem;
			border-radius: 5px;
			cursor: pointer;
			font-family: "noka", sans-serif;
			font-weight: 600;
			font-size: 0.9rem;
			transition: background 0.2s ease;
			min-width: 80px;
		}

		.toggle-button.active {
			background: white;
		}

		.toggle-button:hover {
			background: rgba(255,255,255,0.5);
		}

		.reduced-motion .circle {
			transition: none !important;
			transform: none !important;
		}

		.reduced-motion .circles-layer {
			opacity: 0.5;
		}

		.reduced-motion .content {
			color: white;
			mix-blend-mode: normal;
		}
	</style>
</head>
<body>
	<div class="canvas-container">
		<div class="circles-layer">
			<div class="circle circle-red" id="redCircle"></div>
			<div class="circle circle-green" id="greenCircle"></div>
			<div class="circle circle-blue" id="blueCircle"></div>
		</div>
	</div>

	<div class="content">
		<h1 class="heading" id="mainHeading">RGB Light Mixing</h1>

		<div class="text-content" id="textContent">
		</div>
	</div>

	<div class="gyro-modal" id="gyroModal">
		<button class="gyro-button" id="gyroButton">Enable Gyroscope</button>
		<button class="gyro-cancel" id="gyroCancel">Cancel</button>
	</div>

	<div class="controls-bar">
		<button class="toggle-button active" id="langToggle">EN</button>
		<button class="toggle-button active" id="motionToggle">MOTION</button>
	</div>

	<script>
		// Language content
		const content = {
			en: {
				heading: "COLOUR SPACE",
				button: "Enable Gyroscope",
				cancel: "Cancel",
				paragraphs: [
					"Light mixing is a fundamental principle in physics and visual arts, where different colored lights combine to create new hues through additive color synthesis. Unlike pigment mixing, which is subtractive, light mixing follows the RGB (Red, Green, Blue) color model where colors become brighter as they overlap.",
					"When pure red, green, and blue lights intersect, they create secondary colors: red and green produce yellow, blue and green create cyan, and red and blue form magenta. Where all three primary lights converge, white light emerges—the complete visible spectrum unified.",
					"This phenomenon occurs naturally in various contexts: stage lighting design, computer displays, LED arrays, and even in the aurora borealis where charged particles excite atmospheric gases to emit different colored lights that dance and blend across the night sky.",
					"The gyroscopic movement you're experiencing mirrors how light itself moves and shifts in space. Motion sensors in your device detect orientation changes and translate them into subtle positional shifts of the light circles, creating an immersive, responsive environment that reacts to your physical interaction with the device.",
					"Thomas Young's double-slit experiment first demonstrated light's wave nature, while James Clerk Maxwell later proved that light consists of electromagnetic waves. These discoveries laid the groundwork for understanding how different wavelengths combine to create the rich spectrum of colors we perceive.",
					"In digital displays, millions of tiny RGB sub-pixels work together to create every image you see. Each pixel contains red, green, and blue elements that can be individually controlled to produce any color within the display's gamut—a testament to the power of additive light mixing.",
					"The soft edges and falloff you observe in these circles simulate how light naturally behaves in the physical world. Light intensity decreases with distance from the source, creating gradual transitions rather than sharp boundaries. This natural falloff is what makes light mixing so visually appealing and realistic.",
					"Continue scrolling to explore how these fundamental principles of light and color create an endless dance of hues, where science meets art in a symphony of electromagnetic radiation that our eyes interpret as the beautiful phenomenon we call color."
				]
			},
			pl: {
				heading: "PRZESTRZEŃ BARW",
				button: "Włącz żyroskop",
				cancel: "Anuluj",
				paragraphs: [
					"Mieszanie światła jest fundamentalną zasadą fizyki i sztuk wizualnych, gdzie różnokolorowe światła łączą się, tworząc nowe odcienie poprzez addytywną syntezę kolorów. W przeciwieństwie do mieszania pigmentów, które jest subtraktywne, mieszanie światła opiera się na modelu RGB (czerwony, zielony, niebieski), gdzie kolory stają się jaśniejsze podczas nakładania.",
					"Gdy czyste czerwone, zielone i niebieskie światła przecinają się, tworzą kolory wtórne: czerwony i zielony dają żółty, niebieski i zielony tworzą cyjan, a czerwony i niebieski formują magentę. Tam, gdzie wszystkie trzy podstawowe światła zbiegają się, powstaje białe światło—kompletne widmo widzialne zjednoczone.",
					"To zjawisko występuje naturalnie w różnych kontekstach: projektowanie oświetlenia scenicznego, wyświetlacze komputerowe, macierze LED, a nawet w zorzy polarnej, gdzie naładowane cząsteczki pobudzają gazy atmosferyczne do emitowania różnokolorowych świateł, które tańczą i mieszają się na nocnym niebie.",
					"Żyroskopowy ruch, którego doświadczasz, odzwierciedla sposób, w jaki samo światło porusza się i zmienia w przestrzeni. Czujniki ruchu w Twoim urządzeniu wykrywają zmiany orientacji i przekładają je na subtelne przesunięcia pozycyjne kręgów światła, tworząc immersyjne, responsywne środowisko reagujące na Twoją fizyczną interakcję z urządzeniem.",
					"Eksperyment podwójnej szczeliny Thomasa Younga po raz pierwszy wykazał falową naturę światła, podczas gdy James Clerk Maxwell później udowodnił, że światło składa się z fal elektromagnetycznych. Te odkrycia położyły podwaliny pod zrozumienie tego, jak różne długości fal łączą się, tworząc bogate spektrum kolorów, które postrzegamy.",
					"W wyświetlaczach cyfrowych miliony maleńkich subpikseli RGB współpracują, aby stworzyć każdy obraz, który widzisz. Każdy piksel zawiera czerwone, zielone i niebieskie elementy, które mogą być indywidualnie kontrolowane, aby wytworzyć każdy kolor w gamie wyświetlacza—świadectwo mocy addytywnego mieszania światła.",
					"Miękkie krawędzie i opadanie, które obserwujesz w tych kręgach, symuluje sposób, w jaki światło naturalnie zachowuje się w świecie fizycznym. Intensywność światła maleje wraz z odległością od źródła, tworząc stopniowe przejścia zamiast ostrych granic. To naturalne opadanie sprawia, że mieszanie światła jest tak wizualnie atrakcyjne i realistyczne.",
					"Kontynuuj przewijanie, aby zbadać, jak te fundamentalne zasady światła i koloru tworzą niekończący się taniec odcieni, gdzie nauka spotyka się ze sztuką w symfonii promieniowania elektromagnetycznego, które nasze oczy interpretują jako piękne zjawisko, które nazywamy kolorem."
				]
			}
		};

		class RGBLightMixer {
			constructor() {
				this.circles = {
					red: document.getElementById('redCircle'),
					green: document.getElementById('greenCircle'),
					blue: document.getElementById('blueCircle')
				};

				this.gyroModal = document.getElementById('gyroModal');
				this.gyroButton = document.getElementById('gyroButton');
				this.gyroCancel = document.getElementById('gyroCancel');

				this.gyroEnabled = false;
				this.currentLanguage = this.detectLanguage();
				this.motionReduced = false;

				// Load saved preferences
				this.loadPreferences();

				// Random movement directions for each circle
				this.circleDirections = {
					red: { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 },
					green: { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 },
					blue: { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 }
				};

				this.init();
			}

			detectLanguage() {
				const userLang = navigator.language || navigator.userLanguage;
				return userLang.startsWith('pl') ? 'pl' : 'en';
			}

			loadPreferences() {
				try {
					// Load gyroscope preference
					const gyroPermission = localStorage.getItem('gyroPermission');
					if (gyroPermission === 'granted') {
						this.tryAutoEnableGyro();
					} else if (gyroPermission === 'denied') {
						this.hideGyroPrompt();
					}

					// Load language preference
					const savedLang = localStorage.getItem('preferredLanguage');
					if (savedLang) {
						this.currentLanguage = savedLang;
					}

					// Load motion preference
					this.motionReduced = localStorage.getItem('motionReduced') === 'true';
				} catch (e) {
					console.log('LocalStorage not available');
				}
			}

			savePreferences() {
				try {
					localStorage.setItem('preferredLanguage', this.currentLanguage);
					localStorage.setItem('motionReduced', this.motionReduced);
				} catch (e) {
					console.log('Could not save preferences');
				}
			}

			calculateCirclePositions() {
				const vw = window.innerWidth;
				const vh = window.innerHeight;

				// Much larger circles - fill most of the screen
				const minDimension = Math.min(vw, vh);
				const circleSize = Math.max(minDimension * 1.2, 600); // Minimum 600px, 120% of smallest dimension

				// Center point for triangle formation
				const centerX = vw / 2;
				const centerY = vh / 2;

				// Much larger triangle formation with more separation
				const angle1 = Math.random() * Math.PI * 2;
				const angle2 = angle1 + (Math.PI * 2 / 3) + (Math.random() - 0.5) * 0.3;
				const angle3 = angle2 + (Math.PI * 2 / 3) + (Math.random() - 0.5) * 0.3;

				// Larger distance between circle centers
				const distance = Math.min(vw, vh) * 0.3; // 30% of screen dimension

				const positions = {
					red: {
						x: centerX + Math.cos(angle1) * distance - circleSize / 2,
						y: centerY + Math.sin(angle1) * distance - circleSize / 2,
						size: circleSize
					},
					green: {
						x: centerX + Math.cos(angle2) * distance - circleSize / 2,
						y: centerY + Math.sin(angle2) * distance - circleSize / 2,
						size: circleSize
					},
					blue: {
						x: centerX + Math.cos(angle3) * distance - circleSize / 2,
						y: centerY + Math.sin(angle3) * distance - circleSize / 2,
						size: circleSize
					}
				};

				return positions;
			}

			positionCircles() {
				const positions = this.calculateCirclePositions();

				Object.keys(positions).forEach(color => {
					const circle = this.circles[color];
					const pos = positions[color];

					circle.style.width = pos.size + 'px';
					circle.style.height = pos.size + 'px';
					circle.style.left = pos.x + 'px';
					circle.style.top = pos.y + 'px';
					circle.style.transform = 'none'; // Reset any previous transforms
				});

				// Store base positions for movement calculations
				this.basePositions = positions;
			}

			async tryAutoEnableGyro() {
				console.log('Trying to auto-enable gyroscope...');
				if ('DeviceOrientationEvent' in window) {
					try {
						if (typeof DeviceOrientationEvent.requestPermission === 'function') {
							// iOS - still need to request permission but hide UI if already granted
							this.hideGyroPrompt();
							console.log('iOS device detected, showing permission prompt');
						} else {
							// Android or older iOS - try to enable directly
							this.enableGyroscope();
							this.hideGyroPrompt();
							console.log('Gyroscope auto-enabled');
						}
					} catch (error) {
						console.log('Auto-enable failed:', error);
					}
				}
			}

			hideGyroPrompt() {
				this.gyroModal.style.display = 'none';
			}

			setLanguage() {
				const lang = content[this.currentLanguage];

				document.getElementById('mainHeading').textContent = lang.heading;
				this.gyroButton.textContent = lang.button;
				this.gyroCancel.textContent = lang.cancel;

				// Populate text content from array
				const textContainer = document.getElementById('textContent');
				textContainer.innerHTML = lang.paragraphs.map(para => `<p class="paragraph">${para}</p>`).join('');

				// Update control buttons
				document.getElementById('langToggle').textContent = this.currentLanguage.toUpperCase();
				document.getElementById('motionToggle').classList.toggle('active', !this.motionReduced);
			}

			setupControls() {
				// Language toggle
				document.getElementById('langToggle').addEventListener('click', () => {
					this.currentLanguage = this.currentLanguage === 'en' ? 'pl' : 'en';
					this.setLanguage();
					this.savePreferences();
				});

				// Motion toggle
				document.getElementById('motionToggle').addEventListener('click', () => {
					this.motionReduced = !this.motionReduced;
					document.body.classList.toggle('reduced-motion', this.motionReduced);
					document.getElementById('motionToggle').classList.toggle('active', !this.motionReduced);
					this.savePreferences();
				});

				// Apply saved states
				if (this.motionReduced) {
					document.body.classList.add('reduced-motion');
				}
			}

			init() {
				this.setLanguage();
				this.setupControls();
				this.positionCircles();
				this.setupMouseControls();
				this.setupGyroButton();
				this.startAnimation();

				// Reposition circles on window resize
				window.addEventListener('resize', () => {
					this.positionCircles();
				});
			}

			setupMouseControls() {
				let mouseX = 0.5;
				let mouseY = 0.5;

				document.addEventListener('mousemove', (event) => {
					if (this.motionReduced) return;

					mouseX = event.clientX / window.innerWidth;
					mouseY = event.clientY / window.innerHeight;
					this.updateCirclePositions(mouseX, mouseY);
				});

				// Completely remove touch interference for mobile
			}

			setupGyroButton() {
				this.gyroButton.addEventListener('click', () => {
					this.requestGyroPermission();
				});

				this.gyroCancel.addEventListener('click', () => {
					try {
						localStorage.setItem('gyroPermission', 'denied');
					} catch (e) {
						console.log('Could not save gyro preference');
					}
					this.hideGyroPrompt();
					console.log('Gyroscope permission denied by user');
				});
			}

			async requestGyroPermission() {
				if (!('DeviceOrientationEvent' in window)) {
					this.hideGyroPrompt();
					return;
				}

				try {
					if (typeof DeviceOrientationEvent.requestPermission === 'function') {
						const permission = await DeviceOrientationEvent.requestPermission();

						if (permission === 'granted') {
							try {
								localStorage.setItem('gyroPermission', 'granted');
							} catch (e) {
								console.log('Could not save gyro permission');
							}
							this.enableGyroscope();
							this.hideGyroPrompt();
							console.log('Gyroscope permission granted');
						} else {
							try {
								localStorage.setItem('gyroPermission', 'denied');
							} catch (e) {
								console.log('Could not save gyro denial');
							}
							console.log('Gyroscope permission denied');
							this.hideGyroPrompt();
						}
					} else {
						try {
							localStorage.setItem('gyroPermission', 'granted');
						} catch (e) {
							console.log('Could not save gyro permission');
						}
						this.enableGyroscope();
						this.hideGyroPrompt();
						console.log('Gyroscope enabled (non-iOS)');
					}
				} catch (error) {
					console.log('Gyroscope error:', error);
					this.hideGyroPrompt();
				}
			}

			enableGyroscope() {
				this.gyroEnabled = true;
				console.log('Gyroscope enabled, setting up event listener...');

				// Use a more robust gyroscope handler
				const handleOrientation = (event) => {
					if (this.motionReduced) return;

					// Get orientation values with fallbacks
					let beta = event.beta || 0;   // X-axis rotation (-180 to 180)
					let gamma = event.gamma || 0; // Y-axis rotation (-90 to 90)

					// Clamp values to expected ranges
					beta = Math.max(-180, Math.min(180, beta));
					gamma = Math.max(-90, Math.min(90, gamma));

					// Normalize to 0-1 range
					const normalizedX = (gamma + 90) / 180;
					const normalizedY = (beta + 180) / 360;

					console.log(`Gyro: β=${beta.toFixed(1)}° γ=${gamma.toFixed(1)}° | Normalized: X=${normalizedX.toFixed(2)} Y=${normalizedY.toFixed(2)}`);

					this.updateCirclePositions(normalizedX, normalizedY);
				};

				window.addEventListener('deviceorientation', handleOrientation, { passive: true });

				// Test gyro after a short delay
				setTimeout(() => {
					console.log('Gyroscope should be active now');
				}, 1000);
			}

			updateCirclePositions(inputX, inputY) {
				if (this.motionReduced || !this.basePositions) return;

				const offsetScale = 500;

				// Each circle moves in different random directions from its base position
				Object.keys(this.circles).forEach(color => {
					const circle = this.circles[color];
					const basePos = this.basePositions[color];
					const direction = this.circleDirections[color];

					const offsetX = (inputX - 0.5) * offsetScale * direction.x;
					const offsetY = (inputY - 0.5) * offsetScale * direction.y;

					circle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
				});
			}

			startAnimation() {
				let time = 0;

				const animate = () => {
					if (!this.gyroEnabled && !this.motionReduced) {
						time += 0.01;
						const autoX = 0.5 + Math.sin(time) * 0.1;
						const autoY = 0.5 + Math.cos(time * 0.7) * 0.1;
						this.updateCirclePositions(autoX, autoY);
					}

					requestAnimationFrame(animate);
				};

				animate();
			}
		}

		document.addEventListener('DOMContentLoaded', () => {
			new RGBLightMixer();
		});
	</script>
</body>
</html>