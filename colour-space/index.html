<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>PRZESTRZEŃ BARW</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400;700&display=swap" rel="stylesheet">
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: 'Noto Sans', Arial, sans-serif;
			overflow-x: hidden;
			background: white;
			height: 100vh;
		}

		.canvas-container {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			z-index: 1;
			background: white;
		}

		#lightCanvas {
			width: 100%;
			height: 100%;
			display: block;
		}

		.content {
			position: relative;
			z-index: 2;
			min-height: 100vh;
			padding: 2rem;
			color: white;
			mix-blend-mode: difference;
			overflow-y: auto;
		}

		.heading {
			font-size: clamp(2.5rem, 8vw, 6rem);
			font-weight: 700;
			margin-bottom: 2rem;
			line-height: 1.1;
			text-align: center;
		}

		.text-content {
			font-size: clamp(1rem, 3vw, 1.5rem);
			font-weight: 300;
			line-height: 1.6;
			max-width: 800px;
			margin: 0 auto;
			text-align: justify;
		}

		.paragraph {
			margin-bottom: 2rem;
		}

		@media (max-width: 768px) {
			.content {
				padding: 1rem;
			}

			.text-content {
				text-align: left;
			}
		}

		.gyro-status {
			position: fixed;
			bottom: 1rem;
			right: 1rem;
			background: rgba(0,0,0,0.7);
			color: white;
			padding: 0.5rem 1rem;
			border-radius: 20px;
			font-size: 0.8rem;
			z-index: 3;
			mix-blend-mode: normal;
		}
	</style>
</head>
<body>
	<div class="canvas-container">
		<canvas id="lightCanvas"></canvas>
	</div>

	<div class="content">
		<h1 class="heading">RGB Light Mixing</h1>

		<div class="text-content">
			<p class="paragraph">
				Light mixing is a fundamental principle in physics and visual arts, where different colored lights combine to create new hues through additive color synthesis. Unlike pigment mixing, which is subtractive, light mixing follows the RGB (Red, Green, Blue) color model where colors become brighter as they overlap.
			</p>

			<p class="paragraph">
				When pure red, green, and blue lights intersect, they create secondary colors: red and green produce yellow, blue and green create cyan, and red and blue form magenta. Where all three primary lights converge, white light emerges—the complete visible spectrum unified.
			</p>

			<p class="paragraph">
				This phenomenon occurs naturally in various contexts: stage lighting design, computer displays, LED arrays, and even in the aurora borealis where charged particles excite atmospheric gases to emit different colored lights that dance and blend across the night sky.
			</p>

			<p class="paragraph">
				The gyroscopic movement you're experiencing mirrors how light itself moves and shifts in space. Motion sensors in your device detect orientation changes and translate them into subtle positional shifts of the light circles, creating an immersive, responsive environment that reacts to your physical interaction with the device.
			</p>

			<p class="paragraph">
				Thomas Young's double-slit experiment first demonstrated light's wave nature, while James Clerk Maxwell later proved that light consists of electromagnetic waves. These discoveries laid the groundwork for understanding how different wavelengths combine to create the rich spectrum of colors we perceive.
			</p>

			<p class="paragraph">
				In digital displays, millions of tiny RGB sub-pixels work together to create every image you see. Each pixel contains red, green, and blue elements that can be individually controlled to produce any color within the display's gamut—a testament to the power of additive light mixing.
			</p>

			<p class="paragraph">
				The soft edges and falloff you observe in these circles simulate how light naturally behaves in the physical world. Light intensity decreases with distance from the source, creating gradual transitions rather than sharp boundaries. This natural falloff is what makes light mixing so visually appealing and realistic.
			</p>

			<p class="paragraph">
				Continue scrolling to explore how these fundamental principles of light and color create an endless dance of hues, where science meets art in a symphony of electromagnetic radiation that our eyes interpret as the beautiful phenomenon we call color.
			</p>
		</div>
	</div>

	<div class="gyro-status" id="gyroStatus">Gyroscope: Initializing...</div>

	<script>
		class RGBLightMixer {
			constructor() {
				this.canvas = document.getElementById('lightCanvas');
				this.ctx = this.canvas.getContext('2d');
				this.gyroStatus = document.getElementById('gyroStatus');

				this.circles = [
					{
						baseX: 0.3,
						baseY: 0.4,
						color: [255, 0, 0], // Red
						offsetX: 0,
						offsetY: 0
					},
					{
						baseX: 0.7,
						baseY: 0.4,
						color: [0, 255, 0], // Green
						offsetX: 0,
						offsetY: 0
					},
					{
						baseX: 0.5,
						baseY: 0.7,
						color: [0, 0, 255], // Blue
						offsetX: 0,
						offsetY: 0
					}
				];

				this.gyroSupported = false;
				this.lastGyroTime = 0;

				this.init();
			}

			init() {
				this.setupCanvas();
				this.setupGyroscope();
				this.animate();

				window.addEventListener('resize', () => this.setupCanvas());
			}

			setupCanvas() {
				this.canvas.width = window.innerWidth;
				this.canvas.height = window.innerHeight;

				this.width = window.innerWidth;
				this.height = window.innerHeight;
				this.radius = Math.min(this.width, this.height) * 0.25;
			}

			setupGyroscope() {
				// Check for gyroscope support
				if ('DeviceOrientationEvent' in window) {
					// Request permission for iOS 13+
					if (typeof DeviceOrientationEvent.requestPermission === 'function') {
						DeviceOrientationEvent.requestPermission()
							.then(permissionState => {
								if (permissionState === 'granted') {
									this.enableGyroscope();
								} else {
									this.gyroStatus.textContent = 'Gyroscope: Permission denied';
									this.fallbackToMouse();
								}
							})
							.catch(() => {
								this.gyroStatus.textContent = 'Gyroscope: Permission error';
								this.fallbackToMouse();
							});
					} else {
						// Non-iOS or older iOS
						this.enableGyroscope();
					}
				} else {
					this.gyroStatus.textContent = 'Gyroscope: Not supported';
					this.fallbackToMouse();
				}
			}

			enableGyroscope() {
				this.gyroSupported = true;

				window.addEventListener('deviceorientation', (event) => {
					this.lastGyroTime = Date.now();

					const beta = event.beta || 0;   // X-axis rotation (-180 to 180)
					const gamma = event.gamma || 0; // Y-axis rotation (-90 to 90)

					// Convert to offset values (scaled down for subtle movement)
					const offsetScale = 0.002;

					this.circles.forEach((circle, index) => {
						// Each circle reacts slightly differently
						const multiplier = (index + 1) * 0.7;
						circle.offsetX = gamma * offsetScale * multiplier;
						circle.offsetY = beta * offsetScale * multiplier;
					});

					this.gyroStatus.textContent = `Gyroscope: Active (β:${beta.toFixed(1)}° γ:${gamma.toFixed(1)}°)`;
				});

				// Check if gyroscope data is actually coming through
				setTimeout(() => {
					if (Date.now() - this.lastGyroTime > 2000) {
						this.gyroStatus.textContent = 'Gyroscope: No data, using mouse';
						this.fallbackToMouse();
					}
				}, 3000);
			}

			fallbackToMouse() {
				let mouseX = 0.5;
				let mouseY = 0.5;

				document.addEventListener('mousemove', (event) => {
					mouseX = event.clientX / window.innerWidth;
					mouseY = event.clientY / window.innerHeight;

					const offsetScale = 0.05;

					this.circles.forEach((circle, index) => {
						const multiplier = (index + 1) * 0.3;
						circle.offsetX = (mouseX - 0.5) * offsetScale * multiplier;
						circle.offsetY = (mouseY - 0.5) * offsetScale * multiplier;
					});
				});

				// Touch support for mobile
				document.addEventListener('touchmove', (event) => {
					if (event.touches.length > 0) {
						const touch = event.touches[0];
						mouseX = touch.clientX / window.innerWidth;
						mouseY = touch.clientY / window.innerHeight;

						const offsetScale = 0.05;

						this.circles.forEach((circle, index) => {
							const multiplier = (index + 1) * 0.3;
							circle.offsetX = (mouseX - 0.5) * offsetScale * multiplier;
							circle.offsetY = (mouseY - 0.5) * offsetScale * multiplier;
						});
					}
				});
			}

			createRadialGradient(x, y, color) {
				const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, this.radius);
				gradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 1)`);
				gradient.addColorStop(0.7, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.5)`);
				gradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0)`);
				return gradient;
			}

			drawCircle(circle) {
				const x = (circle.baseX + circle.offsetX) * this.width;
				const y = (circle.baseY + circle.offsetY) * this.height;

				this.ctx.save();
				this.ctx.globalCompositeOperation = 'screen'; // Better blending for web
				this.ctx.fillStyle = this.createRadialGradient(x, y, circle.color);
				this.ctx.beginPath();
				this.ctx.arc(x, y, this.radius, 0, Math.PI * 2);
				this.ctx.fill();
				this.ctx.restore();
			}

			animate() {
				// Clear canvas with white background
				this.ctx.globalCompositeOperation = 'source-over';
				this.ctx.fillStyle = 'white';
				this.ctx.fillRect(0, 0, this.width, this.height);

				// Draw circles with additive blending
				this.circles.forEach(circle => this.drawCircle(circle));

				requestAnimationFrame(() => this.animate());
			}
		}

		// Initialize when DOM is loaded
		document.addEventListener('DOMContentLoaded', () => {
			new RGBLightMixer();

			// Hide gyro status after a few seconds if everything is working
			setTimeout(() => {
				const status = document.getElementById('gyroStatus');
				if (status.textContent.includes('Active')) {
					status.style.opacity = '0.3';
				}
			}, 5000);
		});
	</script>
</body>
</html>